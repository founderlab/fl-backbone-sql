// Generated by CoffeeScript 1.10.0

/*
  backbone-sql.js 0.6.5
  Copyright (c) 2013 Vidigami - https://github.com/vidigami/backbone-sql
  License: MIT (http://www.opensource.org/licenses/mit-license.php)
 */

(function() {
  var Ast, COMPARATORS, COMPARATOR_KEYS, Knex, SqlCursor, _, _appendCondition, _appendConditionalWhere, _appendLimits, _appendSelect, _appendSort, _appendWhere, _appendWhereAst, _columnName, _extractCount, _joinToRelation, _parseSortField, _unjoinResults, buildQueryFromAst, ref, sync,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Knex = require('knex');

  ref = require('backbone-orm'), _ = ref._, sync = ref.sync;

  Ast = require('./ast');

  COMPARATORS = {
    $lt: '<',
    $lte: '<=',
    $gt: '>',
    $gte: '>=',
    $ne: '!='
  };

  COMPARATOR_KEYS = _.keys(COMPARATORS);

  _extractCount = function(count_json) {
    var count_info;
    if (!(count_json != null ? count_json.length : void 0)) {
      return 0;
    }
    count_info = count_json[0];
    return +count_info[count_info.hasOwnProperty('count(*)') ? 'count(*)' : 'count'];
  };

  _appendCondition = function(conditions, key, value, method) {
    var mongo_op, mongo_ops, operations, ops_length, parameter, ref1, ref2, test_str;
    if (method == null) {
      method = 'where';
    }
    if (value != null ? value.$in : void 0) {
      if ((ref1 = value.$in) != null ? ref1.length : void 0) {
        conditions.wheres.push({
          key: key,
          method: 'whereIn',
          value: value.$in
        });
      } else {
        conditions.abort = true;
        return conditions;
      }
    } else if (value != null ? value.$nin : void 0) {
      if ((ref2 = value.$nin) != null ? ref2.length : void 0) {
        conditions.wheres.push({
          key: key,
          method: 'whereNotIn',
          value: value.$nin
        });
      }
    } else if ((value != null ? value.$exists : void 0) != null) {
      conditions.wheres.push({
        method: ((value != null ? value.$exists : void 0) ? 'whereNotNull' : 'whereNull'),
        key: key
      });
    } else if (_.isObject(value) && (ops_length = _.size(mongo_ops = _.pick(value, COMPARATOR_KEYS)))) {
      operations = [];
      for (mongo_op in mongo_ops) {
        parameter = mongo_ops[mongo_op];
        if (_.isNull(value) && (operator !== '$ne')) {
          throw new Error("Unexpected null with query key '" + key + "' operator '" + operator + "'");
        }
        operations.push({
          operator: COMPARATORS[mongo_op],
          value: parameter
        });
      }
      if (ops_length === 1) {
        conditions.where_conditionals.push(_.extend(operations[0], {
          key: key
        }));
      } else {
        conditions.where_conditionals.push({
          key: key,
          operations: operations
        });
      }
    } else if (_.isObject(value) && value.$like) {
      test_str = indexOf.call(value.$like, '%') >= 0 ? value.$like : "%" + value.$like + "%";
      conditions.where_conditionals.push({
        key: key,
        method: method,
        operator: 'ilike',
        value: test_str
      });
    } else if (method === 'where') {
      if (_.isNull(value)) {
        method = 'whereNull';
      }
      conditions.wheres.push({
        key: key,
        value: value,
        method: method
      });
    } else if (method === 'orWhere') {
      if (_.isNull(value)) {
        method = 'orWhereNull';
      }
      console.log('OR', {
        key: key,
        value: value,
        method: method
      });
      conditions.or_wheres.push({
        key: key,
        value: value,
        method: method
      });
    }
    return conditions;
  };

  _columnName = function(col, table) {
    if (table) {
      return table + "." + col;
    } else {
      return col;
    }
  };

  _appendConditionalWhere = function(query, key, condition, table, compound) {
    var whereMethod;
    whereMethod = compound ? 'andWhere' : 'where';
    if (condition.operator === '!=') {
      return query[whereMethod](function() {
        if (_.isNull(condition.value)) {
          return this.whereNotNull(_columnName(key, table));
        } else {
          return this.where(_columnName(key, table), condition.operator, condition.value).orWhereNull(_columnName(key, table));
        }
      });
    } else {
      return query[whereMethod](_columnName(key, table), condition.operator, condition.value);
    }
  };

  _appendWhere = function(query, conditions, table) {
    var condition, i, k, len, len1, ref1, ref2;
    ref1 = conditions.wheres || [];
    for (i = 0, len = ref1.length; i < len; i++) {
      condition = ref1[i];
      query[condition.method](_columnName(condition.key, table), condition.value);
    }
    if (conditions.or_wheres.length) {
      query.where(function() {
        var k, len1, nested_query, ref2, results;
        nested_query = this;
        ref2 = conditions.or_wheres;
        results = [];
        for (k = 0, len1 = ref2.length; k < len1; k++) {
          condition = ref2[k];
          results.push(nested_query[condition.method](_columnName(condition.key, table), condition.value));
        }
        return results;
      });
    }
    ref2 = conditions.where_conditionals;
    for (k = 0, len1 = ref2.length; k < len1; k++) {
      condition = ref2[k];
      if (condition.operations) {
        (function(condition) {
          return query.where(function() {
            var l, len2, nested_query, operation, ref3, results;
            operation = condition.operations.pop();
            nested_query = this;
            _appendConditionalWhere(nested_query, condition.key, operation, table, false);
            ref3 = condition.operations;
            results = [];
            for (l = 0, len2 = ref3.length; l < len2; l++) {
              operation = ref3[l];
              results.push(_appendConditionalWhere(nested_query, condition.key, operation, table, true));
            }
            return results;
          });
        })(condition);
      } else if (_.isNull(condition.value)) {
        query.whereNotNull(_columnName(condition.key, table));
      } else {
        _appendConditionalWhere(query, condition.key, condition, table, false);
      }
    }
    return query;
  };


  /*
  New
   */

  _joinToRelation = function(query, model_type, relation, options) {
    var from_key, pivot_from_key, pivot_table, pivot_to_key, related_model_type, to_key;
    if (options == null) {
      options = {};
    }
    related_model_type = relation.reverse_relation.model_type;
    if (relation.type === 'hasMany' && relation.reverse_relation.type === 'hasMany') {
      pivot_table = relation.join_table.tableName();
      from_key = (model_type.tableName()) + ".id";
      pivot_to_key = pivot_table + "." + relation.foreign_key;
      query.join(pivot_table, from_key, '=', pivot_to_key, 'left outer');
      if (!options.pivot_only) {
        pivot_from_key = pivot_table + "." + relation.reverse_relation.foreign_key;
        to_key = (related_model_type.tableName()) + ".id";
        return query.join(related_model_type.tableName(), pivot_from_key, '=', to_key, 'left outer');
      }
    } else {
      if (relation.type === 'belongsTo') {
        from_key = (model_type.tableName()) + "." + relation.foreign_key;
        to_key = (related_model_type.tableName()) + ".id";
      } else {
        from_key = (model_type.tableName()) + ".id";
        to_key = (related_model_type.tableName()) + "." + relation.foreign_key;
      }
      return query.join(related_model_type.tableName(), from_key, '=', to_key, 'left outer');
    }
  };

  _appendWhereAst = function(query, condition) {
    var ref1;
    if (!_.isUndefined(condition.key)) {
      if (condition.operator) {
        query[condition.method](condition.key, condition.operator, condition.value);
      } else {
        query[condition.method](condition.key, condition.value);
      }
    } else if ((ref1 = condition.conditions) != null ? ref1.length : void 0) {
      query[condition.method](function() {
        var c, i, len, ref2, results, sub_query;
        sub_query = this;
        ref2 = condition.conditions;
        results = [];
        for (i = 0, len = ref2.length; i < len; i++) {
          c = ref2[i];
          results.push(_appendWhereAst(sub_query, c));
        }
        return results;
      });
    }
    return query;
  };

  _parseSortField = function(sort) {
    var col, dir;
    if (sort[0] === '-') {
      dir = 'desc';
      col = sort.substr(1);
    } else {
      dir = 'asc';
      col = sort;
    }
    return [col, dir];
  };

  _appendSelect = function(query, ast) {
    query.select(ast.select);
    return query;
  };

  _appendSort = function(query, sort_fields) {
    var col, dir, i, len, ref1, sort;
    if (!sort_fields) {
      return query;
    }
    for (i = 0, len = sort_fields.length; i < len; i++) {
      sort = sort_fields[i];
      ref1 = _parseSortField(sort), col = ref1[0], dir = ref1[1];
      query.orderBy(col, dir);
    }
    return query;
  };

  _appendLimits = function(query, limit, offset) {
    if (limit) {
      query.limit(limit);
    }
    if (offset) {
      query.offset(offset);
    }
    return query;
  };

  buildQueryFromAst = function(query, ast, options) {
    var join, key, ref1;
    if (options == null) {
      options = {};
    }
    _appendWhereAst(query, ast.where);
    if (ast.count || options.count) {
      return query.count('*');
    }
    if (ast.exists || options.exists) {
      return query.count('*').limit(1);
    }
    _appendSelect(query, ast);
    _appendSort(query, ast.sort);
    if (_.size(ast.joins)) {
      ref1 = ast.joins;
      for (key in ref1) {
        join = ref1[key];
        console.log('Processing join:', key);
        _joinToRelation(query, ast.model_type, join.relation, {
          pivot_only: join.pivot_only && !(join.include || join.condition)
        });
      }
    } else {
      _appendLimits(query, ast.limit, ast.offset);
    }
    return query;
  };

  _unjoinResults = function(raw_json, ast, parseJson) {
    var found, i, join, json, key, len, match, model_json, model_type, ref1, related_json, relation_key, reverse_relation_schema, row, row_relation_json, value;
    if (!(raw_json && raw_json.length)) {
      return raw_json;
    }
    json = [];
    model_type = ast.model_type;
    for (i = 0, len = raw_json.length; i < len; i++) {
      row = raw_json[i];
      model_json = {};
      row_relation_json = {};
      for (key in row) {
        value = row[key];
        if (match = ast.prefixRegex().exec(key)) {
          model_json[match[1]] = value;
        } else {
          ref1 = ast.joins;
          for (relation_key in ref1) {
            join = ref1[relation_key];
            if (!join.include) {
              continue;
            }
            related_json = (row_relation_json[relation_key] || (row_relation_json[relation_key] = {}));
            if (match = ast.prefixRegex(join.model_type.tableName()).exec(key)) {
              related_json[match[1]] = value;
            }
          }
        }
      }
      if (found = _.find(json, function(test) {
        return test.id === model_json.id;
      })) {
        model_json = found;
      } else {
        json.push(model_json);
      }
      for (relation_key in row_relation_json) {
        related_json = row_relation_json[relation_key];
        if (_.isNull(related_json.id)) {
          if (model_type.relation(relation_key).type === 'hasMany') {
            model_json[relation_key] = [];
          } else {
            model_json[relation_key] = null;
          }
        } else if (!_.isEmpty(related_json)) {
          reverse_relation_schema = model_type.relation(relation_key).reverse_relation.model_type.schema();
          related_json = parseJson(related_json, reverse_relation_schema);
          if (model_type.relation(relation_key).type === 'hasMany') {
            model_json[relation_key] || (model_json[relation_key] = []);
            if (!_.find(model_json[relation_key], function(test) {
              return test.id === related_json.id;
            })) {
              model_json[relation_key].push(related_json);
            }
          } else {
            model_json[relation_key] = related_json;
          }
        }
      }
    }
    return json;
  };

  module.exports = SqlCursor = (function(superClass) {
    extend(SqlCursor, superClass);

    function SqlCursor() {
      this._exec = bind(this._exec, this);
      return SqlCursor.__super__.constructor.apply(this, arguments);
    }

    SqlCursor.prototype.verbose = false;

    SqlCursor.prototype._parseConditions = function(find, cursor, conditions, method) {
      var base, cond, i, key, len, name, ref1, ref2, related_conditions, related_wheres, relation, reverse_relation, value;
      if (conditions == null) {
        conditions = {
          wheres: [],
          or_wheres: [],
          where_conditionals: [],
          related_wheres: {},
          joined_wheres: {}
        };
      }
      if (method == null) {
        method = 'where';
      }
      related_wheres = {};
      for (key in find) {
        value = find[key];
        if (_.isUndefined(value)) {
          throw new Error("Unexpected undefined for query key '" + key + "'");
        }
        if (key.indexOf('.') > 0) {
          ref1 = key.split('.'), relation = ref1[0], key = ref1[1];
          related_wheres[relation] || (related_wheres[relation] = {});
          related_wheres[relation][key] = value;
        } else if ((reverse_relation = this.model_type.reverseRelation(key)) && reverse_relation.join_table) {
          console.dir("'**************" + key + "****************'", {
            colors: true
          });
          relation = reverse_relation.reverse_relation;
          console.log('relation.key', relation.key);
          (base = conditions.joined_wheres)[name = relation.key] || (base[name] = {
            wheres: [],
            or_wheres: [],
            where_conditionals: []
          });
          _appendCondition(conditions.joined_wheres[relation.key], key, value, method);
        } else {
          _appendCondition(conditions, key, value, method);
        }
      }
      for (relation in related_wheres) {
        related_conditions = related_wheres[relation];
        conditions.related_wheres[relation] = this._parseConditions(related_conditions);
      }
      if (cursor != null ? cursor.$or : void 0) {
        ref2 = cursor.$or;
        for (i = 0, len = ref2.length; i < len; i++) {
          cond = ref2[i];
          this._parseConditions(cond, {}, conditions, 'orWhere');
        }
      }
      if (cursor != null ? cursor.$ids : void 0) {
        if (!cursor.$ids.length) {
          conditions.abort = true;
          return conditions;
        }
        conditions.wheres.push({
          method: 'whereIn',
          key: 'id',
          value: cursor.$ids
        });
      }
      return conditions;
    };

    SqlCursor.prototype.execUnique = function(callback) {
      var ast, err, error, query, rank_field, ref1, ref2, sort_dir, sort_field, subquery;
      try {
        this._conditions = this._parseConditions(this._find, this._cursor);
        ast = new Ast({
          find: this._find,
          cursor: this._cursor,
          model_type: this.model_type,
          prefix_columns: false
        });
        query = this.connection(this.model_type.tableName());
        query = buildQueryFromAst(query, ast);
        console.log('========================query=========================');
        if (this._cursor.$count) {
          query.count().from(this.connection.distinct(this._cursor.$unique).from(this.model_type.tableName()).as('count_query'));
          return query.exec((function(_this) {
            return function(err, count_json) {
              return callback(err, _extractCount(count_json));
            };
          })(this));
        }
        if (_.difference(ast.select, this._cursor.$unique).length === 0) {
          query.distinct(ast.select);
        } else {
          rank_field = this._cursor.$unique[0];
          ref2 = this._parseSortField(((ref1 = ast.sort) != null ? ref1[0] : void 0) || 'id'), sort_field = ref2[0], sort_dir = ref2[1];
          subquery = this.connection.select(this.connection.raw((ast.select.join(', ')) + ", rank() over (partition by " + rank_field + " order by " + sort_field + " " + sort_dir + ")"));
          subquery.from(this.model_type.tableName()).as('subquery');
          query.select(ast.select).from(subquery).where('rank', 1);
        }
        console.dir(query.toString(), {
          depth: null,
          colors: true
        });
        return this._exec(query, ast, callback);
      } catch (error) {
        err = error;
        return callback(new Error("Query failed for model: " + this.model_type.model_name + " with error: " + err));
      }
    };

    SqlCursor.prototype.queryToJSON = function(callback) {
      var $columns, ast, err, error, query, query_old;
      if (this.hasCursorQuery('$zero')) {
        return callback(null, this.hasCursorQuery('$one') ? null : []);
      }
      if (this._cursor.$unique) {
        return this.execUnique(callback);
      }
      try {
        this._conditions = this._parseConditions(this._find, this._cursor);
        if (this._conditions.abort) {
          return callback(null, this._cursor.$count ? 0 : (this._cursor.$one ? null : []));
        }

        /*
         */
        console.log();
        console.log();
        console.log();
        ast = new Ast({
          find: this._find,
          cursor: this._cursor,
          model_type: this.model_type
        });
        ast.print();
        console.log('<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<');
        console.dir(this._conditions, {
          depth: null,
          colors: true
        });
        console.log('<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<');
        console.log();
        console.log();
        query = this.connection(this.model_type.tableName());
        query = buildQueryFromAst(query, ast);
        this.joined = true;
      } catch (error) {
        err = error;
        return callback("Query failed for model: " + this.model_type.model_name + " with error: " + err);
      }
      if (this._cursor.$count || this._cursor.$exists) {
        return query.exec((function(_this) {
          return function(err, count_json) {
            var count;
            if (err) {
              return callback(err);
            }
            count = _extractCount(count_json);
            return callback(null, _this._cursor.$count ? count : count > 0);
          };
        })(this));
      }
      if (true) {
        console.log('=======================query_old=======================');
        query_old = this.connection(this.model_type.tableName());
        _appendWhere(query_old, this._conditions, this.model_type.tableName());
        $columns = this.joined ? this._prefixColumns(this.model_type, ast.fields) : this._columns(this.model_type, ast.fields);
        query_old.select($columns);
        this._appendRelatedWheres(query_old);
        this._appendJoinedWheres(query_old);
        console.dir(query_old.toString(), {
          depth: null,
          colors: true
        });
        console.log('=======================================================');
        console.log();
        console.log();
      }
      console.log('========================query=========================');
      console.dir(query.toString(), {
        depth: null,
        colors: true
      });
      return this._exec(query, ast, callback);
    };

    SqlCursor.prototype._exec = function(query, ast, callback) {
      if (this.verbose) {
        console.log('\n----------');
        console.dir(query.toString(), {
          depth: null,
          colors: true
        });
        console.log('----------');
      }
      return query.exec((function(_this) {
        return function(err, json) {
          console.log('PRE UNJOIN JSON:');
          console.dir(json, {
            depth: null,
            colors: true
          });
          if (err) {
            return callback(new Error("Query failed for model: " + _this.model_type.model_name + " with error: " + err));
          }
          if (ast.prefix_columns) {
            json = _unjoinResults(json, ast, _this.backbone_adapter.nativeToAttributes);
          }
          console.log('UNJOINED JSON:');
          console.dir(json, {
            depth: null,
            colors: true
          });
          console.log('joinedIncludesWithConditions', ast.joinedIncludesWithConditions());
          if (ast.joinedIncludesWithConditions().length) {
            return _this._appendCompleteRelations(json, ast, callback);
          } else {
            return _this._processResponse(json, ast, callback);
          }
        };
      })(this));
    };

    SqlCursor.prototype._processResponse = function(json, ast, callback) {
      var i, len, model_json, number, query, query_old, schema, subquery;
      schema = this.model_type.schema();
      for (i = 0, len = json.length; i < len; i++) {
        model_json = json[i];
        this.backbone_adapter.nativeToAttributes(model_json, schema);
      }
      json = this.selectResults(json);
      if (this._cursor.$include) {
        console.log(this._cursor);
        if (this._cursor.$offset) {
          number = json.length - this._cursor.$offset;
          if (number < 0) {
            number = 0;
          }
          json = number ? json.slice(this._cursor.$offset, this._cursor.$offset + number) : [];
        }
        if (this._cursor.$limit) {
          json = json.splice(0, Math.min(json.length, this._cursor.$limit));
        }
      }
      if (this._cursor.$page) {
        query = this.connection();
        query = buildQueryFromAst(query, ast, {
          count: true
        });
        query_old = this.connection();
        _appendWhere(query_old, this._conditions, this.model_type.tableName());
        this._appendRelatedWheres(query_old);
        this._appendJoinedWheres(query_old);
        query_old.count('*');
        console.log('--------NEW---------');
        console.dir(query.toString(), {
          colors: true
        });
        console.log('-----------------');
        console.log('--------OLD---------');
        console.dir(query_old.toString(), {
          colors: true
        });
        console.log('-----------------');
        if (this._cursor.$unique) {
          subquery = this.connection.distinct(this._cursor.$unique);
          subquery.from(this.model_type.tableName()).as('subquery');
          query.from(subquery);
        } else {
          query.from(this.model_type.tableName());
        }
        if (this.verbose) {
          console.log('\n---------- counting rows for $page ----------');
          console.dir(query.toString(), {
            colors: true
          });
          console.log('---------------------------------------------');
        }
        return query.exec((function(_this) {
          return function(err, count_json) {
            if (err) {
              return callback(err);
            }
            console.log('\nFINAL (count):', {
              offset: _this._cursor.$offset || 0,
              total_rows: _extractCount(count_json),
              rows: json
            });
            return callback(null, {
              offset: _this._cursor.$offset || 0,
              total_rows: _extractCount(count_json),
              rows: json
            });
          };
        })(this));
      } else {
        console.log('\nnFINAL JSON:');
        console.dir(json, {
          depth: null,
          colors: true
        });
        return callback(null, json);
      }
    };

    SqlCursor.prototype._appendCompleteRelations = function(json, ast, callback) {
      var j, relation_ast, relation_query;
      relation_ast = new Ast({
        model_type: this.model_type,
        query: {
          id: {
            $in: _.pluck(json, 'id')
          },
          $select: ['id'],
          $include: (function() {
            var i, len, ref1, results;
            ref1 = ast.joinedIncludesWithConditions();
            results = [];
            for (i = 0, len = ref1.length; i < len; i++) {
              j = ref1[i];
              results.push(j.key);
            }
            return results;
          })()
        }
      });
      relation_query = this.connection(this.model_type.tableName());
      relation_query = buildQueryFromAst(relation_query, relation_ast);
      return relation_query.exec((function(_this) {
        return function(err, raw_relation_json) {
          var i, len, model, placeholder, relation_json;
          if (err) {
            return callback(err);
          }
          relation_json = _unjoinResults(raw_relation_json, relation_ast, _this.backbone_adapter.nativeToAttributes);
          for (i = 0, len = relation_json.length; i < len; i++) {
            placeholder = relation_json[i];
            model = _.find(json, function(test) {
              return test.id === placeholder.id;
            });
            _.extend(model, placeholder);
          }
          return _this._processResponse(json, ast, callback);
        };
      })(this));
    };

    SqlCursor.prototype._appendRelatedWheres = function(query) {
      var key, ref1, related_wheres, relation, results;
      if (_.isEmpty(this._conditions.related_wheres)) {
        return;
      }
      this.joined = true;
      if (this.include_keys) {
        this._conditions.related_wheres = _.omit(this._conditions.related_wheres, this.include_keys);
      }
      ref1 = this._conditions.related_wheres;
      results = [];
      for (key in ref1) {
        related_wheres = ref1[key];
        relation = this._getRelation(key);
        this._joinTo(query, relation);
        results.push(_appendWhere(query, related_wheres, relation.reverse_relation.model_type.tableName()));
      }
      return results;
    };

    SqlCursor.prototype._appendJoinedWheres = function(query) {
      var from_key, joined_wheres, key, ref1, relation, results, to_key;
      if (_.isEmpty(this._conditions.joined_wheres)) {
        return;
      }
      this.joined = true;
      ref1 = this._conditions.joined_wheres;
      results = [];
      for (key in ref1) {
        joined_wheres = ref1[key];
        relation = this._getRelation(key);
        console.log('_appendJoinedWheres', key);
        if (!(indexOf.call(_.keys(this._conditions.related_wheres), key) >= 0 || (this.include_keys && indexOf.call(this.include_keys, key) >= 0))) {
          from_key = (this.model_type.tableName()) + ".id";
          to_key = (relation.join_table.tableName()) + "." + relation.foreign_key;
          query.join(relation.join_table.tableName(), from_key, '=', to_key, 'left outer');
        }
        results.push(_appendWhere(query, joined_wheres, relation.join_table.tableName()));
      }
      return results;
    };

    SqlCursor.prototype._columns = function(model_type, fields) {
      var columns;
      columns = fields ? _.clone(fields) : model_type.schema().columns();
      if (indexOf.call(columns, 'id') < 0) {
        columns.push('id');
      }
      return columns;
    };

    SqlCursor.prototype._prefixColumns = function(model_type, fields) {
      var col, columns;
      columns = fields ? _.clone(fields) : model_type.schema().columns();
      if (indexOf.call(columns, 'id') < 0) {
        columns.push('id');
      }
      return (function() {
        var i, len, results;
        results = [];
        for (i = 0, len = columns.length; i < len; i++) {
          col = columns[i];
          results.push((model_type.tableName()) + "." + col + " as " + (this._tablePrefix(model_type)) + col);
        }
        return results;
      }).call(this);
    };

    SqlCursor.prototype._tablePrefix = function(model_type) {
      return (model_type.tableName()) + "_";
    };

    SqlCursor.prototype._prefixRegex = function(model_type) {
      return new RegExp("^" + (this._tablePrefix(model_type)) + "(.*)$");
    };

    SqlCursor.prototype._getRelation = function(key) {
      var relation;
      if (!(relation = this.model_type.relation(key))) {
        throw new Error(key + " is not a relation of " + this.model_type.model_name);
      }
      return relation;
    };

    SqlCursor.prototype._joinTo = function(query, relation) {
      var from_key, pivot_from_key, pivot_table, pivot_to_key, related_model_type, to_key;
      related_model_type = relation.reverse_relation.model_type;
      if (relation.type === 'hasMany' && relation.reverse_relation.type === 'hasMany') {
        pivot_table = relation.join_table.tableName();
        from_key = (this.model_type.tableName()) + ".id";
        pivot_to_key = pivot_table + "." + relation.foreign_key;
        query.join(pivot_table, from_key, '=', pivot_to_key, 'left outer');
        pivot_from_key = pivot_table + "." + relation.reverse_relation.foreign_key;
        to_key = (related_model_type.tableName()) + ".id";
        return query.join(related_model_type.tableName(), pivot_from_key, '=', to_key, 'left outer');
      } else {
        if (relation.type === 'belongsTo') {
          from_key = (this.model_type.tableName()) + "." + relation.foreign_key;
          to_key = (related_model_type.tableName()) + ".id";
        } else {
          from_key = (this.model_type.tableName()) + ".id";
          to_key = (related_model_type.tableName()) + "." + relation.foreign_key;
        }
        return query.join(related_model_type.tableName(), from_key, '=', to_key, 'left outer');
      }
    };

    return SqlCursor;

  })(sync.Cursor);

}).call(this);
