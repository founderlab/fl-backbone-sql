// Generated by CoffeeScript 1.10.0

/*
  backbone-sql.js 0.6.5
  Copyright (c) 2013 Vidigami - https://github.com/vidigami/backbone-sql
  License: MIT (http://www.opensource.org/licenses/mit-license.php)
 */

(function() {
  var Ast, Knex, SqlCursor, _, buildQueryFromAst, extractCount, ref, sync,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Knex = require('knex');

  ref = require('backbone-orm'), _ = ref._, sync = ref.sync;

  Ast = require('./ast');

  buildQueryFromAst = require('./query_builder');

  extractCount = function(count_json) {
    var count_info;
    if (!(count_json != null ? count_json.length : void 0)) {
      return 0;
    }
    count_info = count_json[0];
    return +count_info[count_info.hasOwnProperty('count(*)') ? 'count(*)' : 'count'];
  };

  module.exports = SqlCursor = (function(superClass) {
    extend(SqlCursor, superClass);

    function SqlCursor() {
      this.unjoinResults = bind(this.unjoinResults, this);
      this.fetchIncludedRelations = bind(this.fetchIncludedRelations, this);
      this.processResponse = bind(this.processResponse, this);
      this.runQuery = bind(this.runQuery, this);
      this.queryToJSON = bind(this.queryToJSON, this);
      this.execUnique = bind(this.execUnique, this);
      return SqlCursor.__super__.constructor.apply(this, arguments);
    }

    SqlCursor.prototype.verbose = false;

    SqlCursor.prototype.execUnique = function(callback) {
      var ast, err, error, query, rank_field, ref1, ref2, sort_dir, sort_field, subquery;
      try {
        ast = new Ast({
          find: this._find,
          cursor: this._cursor,
          model_type: this.model_type,
          prefix_columns: false
        });
        query = this.connection(this.model_type.tableName());
        query = buildQueryFromAst(query, ast);
        if (this._cursor.$count) {
          query.count().from(this.connection.distinct(this._cursor.$unique).from(this.model_type.tableName()).as('count_query'));
          return query.exec((function(_this) {
            return function(err, count_json) {
              return callback(err, extractCount(count_json));
            };
          })(this));
        }
        if (_.difference(ast.select, this._cursor.$unique).length === 0) {
          query.distinct(ast.select);
        } else {
          rank_field = this._cursor.$unique[0];
          ref2 = require('./query_builder').parseSortField(((ref1 = ast.sort) != null ? ref1[0] : void 0) || 'id'), sort_field = ref2[0], sort_dir = ref2[1];
          subquery = this.connection.select(this.connection.raw((ast.select.join(', ')) + ", rank() over (partition by " + rank_field + " order by " + sort_field + " " + sort_dir + ")"));
          subquery.from(this.model_type.tableName()).as('subquery');
          query.select(ast.select).from(subquery).where('rank', 1);
        }
        return this.runQuery(query, ast, callback);
      } catch (error) {
        err = error;
        return callback(new Error("Query failed for model: " + this.model_type.model_name + " with error: " + err));
      }
    };

    SqlCursor.prototype.queryToJSON = function(callback) {
      var ast, err, error, query;
      if (this.hasCursorQuery('$zero')) {
        return callback(null, this.hasCursorQuery('$one') ? null : []);
      }
      if (this.hasCursorQuery('$count')) {
        this._cursor.$count = true;
      }
      if (this.hasCursorQuery('$exists')) {
        this._cursor.$exists = true;
      }
      if (this._cursor.$unique) {
        return this.execUnique(callback);
      }
      try {
        ast = new Ast({
          find: this._find,
          cursor: this._cursor,
          model_type: this.model_type
        });
        query = this.connection(this.model_type.tableName());
        query = buildQueryFromAst(query, ast);
        if (ast.abort) {
          return callback(null, this._cursor.$count ? 0 : (this._cursor.$one ? null : []));
        }
      } catch (error) {
        err = error;
        return callback("Query failed for model: " + this.model_type.model_name + " with error: " + err);
      }
      return this.runQuery(query, ast, callback);
    };

    SqlCursor.prototype.runQuery = function(query, ast, callback) {
      if (this.verbose) {
        console.log('\n----------');
        console.dir(query.toString(), {
          depth: null,
          colors: true
        });
        console.log('----------');
      }
      return query.exec((function(_this) {
        return function(err, json) {
          var count;
          if (err) {
            return callback(new Error("Query failed for model: " + _this.model_type.model_name + " with error: " + err));
          }
          if (_this.hasCursorQuery('$count') || _this.hasCursorQuery('$exists')) {
            count = extractCount(json);
            return callback(null, _this.hasCursorQuery('$count') ? count : count > 0);
          }
          if (ast.prefix_columns) {
            json = _this.unjoinResults(json, ast);
          }
          if (ast.joinedIncludesWithConditions().length) {
            return _this.fetchIncludedRelations(json, ast, callback);
          } else {
            return _this.processResponse(json, ast, callback);
          }
        };
      })(this));
    };

    SqlCursor.prototype.processResponse = function(json, ast, callback) {
      var i, len, model_json, number, query, schema, subquery;
      schema = this.model_type.schema();
      for (i = 0, len = json.length; i < len; i++) {
        model_json = json[i];
        this.backbone_adapter.nativeToAttributes(model_json, schema);
      }
      json = this.selectResults(json);
      if (this._cursor.$include) {
        if (this._cursor.$offset) {
          number = json.length - this._cursor.$offset;
          if (number < 0) {
            number = 0;
          }
          json = number ? json.slice(this._cursor.$offset, this._cursor.$offset + number) : [];
        }
        if (this._cursor.$limit) {
          json = json.splice(0, Math.min(json.length, this._cursor.$limit));
        }
      }
      if (this.hasCursorQuery('$page')) {
        query = this.connection();
        query = buildQueryFromAst(query, ast, {
          count: true
        });
        if (this._cursor.$unique) {
          subquery = this.connection.distinct(this._cursor.$unique);
          subquery.from(this.model_type.tableName()).as('subquery');
          query.from(subquery);
        } else {
          query.from(this.model_type.tableName());
        }
        if (this.verbose) {
          console.log('\n---------- counting rows for $page ----------');
          console.dir(query.toString(), {
            colors: true
          });
          console.log('---------------------------------------------');
        }
        return query.exec((function(_this) {
          return function(err, count_json) {
            if (err) {
              return callback(err);
            }
            return callback(null, {
              offset: _this._cursor.$offset || 0,
              total_rows: extractCount(count_json),
              rows: json
            });
          };
        })(this));
      } else {
        return callback(null, json);
      }
    };

    SqlCursor.prototype.fetchIncludedRelations = function(json, ast, callback) {
      var j, relation_ast, relation_query;
      relation_ast = new Ast({
        model_type: this.model_type,
        query: {
          id: {
            $in: _.pluck(json, 'id')
          },
          $select: ['id'],
          $include: (function() {
            var i, len, ref1, results;
            ref1 = ast.joinedIncludesWithConditions();
            results = [];
            for (i = 0, len = ref1.length; i < len; i++) {
              j = ref1[i];
              results.push(j.key);
            }
            return results;
          })()
        }
      });
      relation_query = this.connection(this.model_type.tableName());
      relation_query = buildQueryFromAst(relation_query, relation_ast);
      return relation_query.exec((function(_this) {
        return function(err, raw_relation_json) {
          var i, len, model, placeholder, relation_json;
          if (err) {
            return callback(err);
          }
          relation_json = _this.unjoinResults(raw_relation_json, relation_ast);
          for (i = 0, len = relation_json.length; i < len; i++) {
            placeholder = relation_json[i];
            model = _.find(json, function(test) {
              return test.id === placeholder.id;
            });
            _.extend(model, placeholder);
          }
          return _this.processResponse(json, ast, callback);
        };
      })(this));
    };

    SqlCursor.prototype.unjoinResults = function(raw_json, ast) {
      var found, i, join, json, key, len, match, model_json, model_type, ref1, related_json, relation_key, reverse_relation_schema, row, row_relation_json, value;
      if (!(raw_json && raw_json.length)) {
        return raw_json;
      }
      json = [];
      model_type = ast.model_type;
      for (i = 0, len = raw_json.length; i < len; i++) {
        row = raw_json[i];
        model_json = {};
        row_relation_json = {};
        for (key in row) {
          value = row[key];
          if (match = ast.prefixRegex().exec(key)) {
            model_json[match[1]] = value;
          } else {
            ref1 = ast.joins;
            for (relation_key in ref1) {
              join = ref1[relation_key];
              if (!join.include) {
                continue;
              }
              related_json = (row_relation_json[relation_key] || (row_relation_json[relation_key] = {}));
              if (match = ast.prefixRegex(join.model_type.tableName()).exec(key)) {
                related_json[match[1]] = value;
              }
            }
          }
        }
        if (found = _.find(json, function(test) {
          return test.id === model_json.id;
        })) {
          model_json = found;
        } else {
          json.push(model_json);
        }
        for (relation_key in row_relation_json) {
          related_json = row_relation_json[relation_key];
          if (_.isNull(related_json.id)) {
            if (model_type.relation(relation_key).type === 'hasMany') {
              model_json[relation_key] = [];
            } else {
              model_json[relation_key] = null;
            }
          } else if (!_.isEmpty(related_json)) {
            reverse_relation_schema = model_type.relation(relation_key).reverse_relation.model_type.schema();
            related_json = this.backbone_adapter.nativeToAttributes(related_json, reverse_relation_schema);
            if (model_type.relation(relation_key).type === 'hasMany') {
              model_json[relation_key] || (model_json[relation_key] = []);
              if (!_.find(model_json[relation_key], function(test) {
                return test.id === related_json.id;
              })) {
                model_json[relation_key].push(related_json);
              }
            } else {
              model_json[relation_key] = related_json;
            }
          }
        }
      }
      return json;
    };

    return SqlCursor;

  })(sync.Cursor);

}).call(this);
