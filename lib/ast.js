// Generated by CoffeeScript 1.10.0

/*
  backbone-sql.js 0.6.5
  Copyright (c) 2013 Vidigami - https://github.com/vidigami/backbone-sql
  License: MIT (http://www.opensource.org/licenses/mit-license.php)
 */

(function() {
  var COMPARATORS, COMPARATOR_KEYS, SqlAst, _, columnName,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ = require('lodash');

  COMPARATORS = {
    $lt: '<',
    $lte: '<=',
    $gt: '>',
    $gte: '>=',
    $ne: '!=',
    $eq: '='
  };

  COMPARATOR_KEYS = _.keys(COMPARATORS);


  /*
  tree = {
  
    select: ['t.id', 't.name'],
  
    where: {
      method: 'where',
      conditions: [{
        method: 'where',
        column: 't.id',
        value: 1,
      }, {
        method: 'where',
        operator: '>',
        column: 't.id',
        value: 2,
      }, {
        method: 'where',
        conditions: [
          {method: 'orWhere', column: 't.id', value: 2},
          {method: 'orWhere', column: 't.id', value: 3},
          {method: 'orWhere', column: 't.id', operator: '>=' value: 99},
        ],
      }],
    },
  
    join: {
  
    },
  
    sort: ['t.id'],
  
    limit: 5,
  
  }
   */

  columnName = function(col, table) {
    if (table) {
      return table + "." + col;
    } else {
      return col;
    }
  };

  module.exports = SqlAst = (function() {
    function SqlAst() {
      this.select = [];
      this.where = {
        method: 'where',
        conditions: []
      };
      this.join = {};
      this.sort = null;
      this.limit = null;
    }

    SqlAst.prototype.print = function() {
      console.log('********************** AST ******************************');
      console.log('---- Input ----');
      console.log('> query:', this.query);
      console.log();
      console.log('----  AST  ----');
      console.log('> select:', this.select);
      console.log('> where:');
      console.dir(this.where, {
        depth: null,
        colors: true
      });
      console.log('> join:', this.join);
      console.log('> sort:', this.sort);
      console.log('> limit:', this.limit);
      return console.log('---------------------------------------------------------');
    };

    SqlAst.prototype.parse = function(options) {
      this.find = options.find || {};
      this.cursor = options.cursor || {};
      this.query = _.extend({}, this.find, this.cursor);
      this.model_type = options.model_type;
      if (this.cursor.$sort) {
        this.sort = _.isArray(this.cursor.$sort) ? this.cursor.$sort : [this.cursor.$sort];
      }
      if (this.cursor.$values) {
        this.fields = this.cursor.$whitelist ? _.intersection(this.cursor.$values, this.cursor.$whitelist) : this.cursor.$values;
      } else if (this.cursor.$select) {
        this.fields = this.cursor.$whitelist ? _.intersection(this.cursor.$select, this.cursor.$whitelist) : this.cursor.$select;
      } else if (this.cursor.$whitelist) {
        this.fields = this.cursor.$whitelist;
      }
      return this._parse(this.query, {
        table: this.model_type.tableName()
      });
    };

    SqlAst.prototype._parse = function(query, options) {
      var cond, i, key, len, q, ref, results, reverse_relation, table, value;
      if (options == null) {
        options = {};
      }
      table = options.table;
      for (key in query) {
        value = query[key];
        if (!(key[0] !== '$')) {
          continue;
        }
        if (_.isUndefined(value)) {
          throw new Error("Unexpected undefined for query key '" + key + "'");
        }
        if (key.indexOf('.') > 0) {
          this.parseDotRelation(key, value);
        } else if ((reverse_relation = this.model_type.reverseRelation(key)) && reverse_relation.join_table) {
          this.parseManyToManyRelation(key, value, reverse_relation);
        } else {
          cond = this.parseCondition(key, value, {
            table: table,
            method: options.method
          });
          this.where.conditions.push(cond);
        }
      }
      if (query != null ? query.$ids : void 0) {
        cond = this.parseCondition({
          key: 'id',
          value: query.$ids
        }, {
          table: table,
          method: 'whereIn'
        });
        this.where.conditions.push(cond);
      }
      if (query != null ? query.$or : void 0) {
        ref = query.$or;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          q = ref[i];
          results.push(this._parse(q, {
            table: table,
            method: 'orWhere'
          }));
        }
        return results;
      }
    };

    SqlAst.prototype.parseCondition = function(key, value, options) {
      var condition, method, mongo_conditions, mongo_op, operator, val;
      if (options == null) {
        options = {};
      }
      method = options.method || 'where';
      key = columnName(key, options.table);
      condition = {};
      if (_.isObject(value)) {
        condition = {
          method: method,
          conditions: []
        };
        if (value != null ? value.$in : void 0) {
          condition.conditions.push({
            key: key,
            method: 'whereIn',
            value: value.$in
          });
        }
        if (value != null ? value.$nin : void 0) {
          condition.conditions.push({
            key: key,
            method: 'whereNotIn',
            value: value.$nin
          });
        }
        if ((value != null ? value.$exists : void 0) != null) {
          condition.conditions.push({
            key: key,
            method: ((value != null ? value.$exists : void 0) ? 'whereNotNull' : 'whereNull')
          });
        }
        if (_.isObject(value) && value.$like) {
          val = indexOf.call(value.$like, '%') >= 0 ? value.$like : "%" + value.$like + "%";
          condition.conditions.push({
            key: key,
            method: method,
            operator: 'ilike',
            value: val
          });
        }
        if (_.size(mongo_conditions = _.pick(value, COMPARATOR_KEYS))) {
          for (mongo_op in mongo_conditions) {
            val = mongo_conditions[mongo_op];
            operator = COMPARATORS[mongo_op];
            if (mongo_op === '$ne') {
              if (_.isNull(val)) {
                condition.conditions.push({
                  key: key,
                  method: method + "NotNull"
                });
              } else {
                condition.conditions.push({
                  method: method,
                  conditions: [
                    {
                      key: key,
                      operator: operator,
                      method: 'orWhere',
                      value: val
                    }, {
                      key: key,
                      method: 'orWhereNull'
                    }
                  ]
                });
              }
            } else if (_.isNull(val)) {
              if (mongo_op === '$eq') {
                condition.conditions.push({
                  key: key,
                  method: method + "Null"
                });
              } else {
                throw new Error("Unexpected null with query key '" + key + "': '" + mongo_conditions + "'");
              }
            } else {
              condition.conditions.push({
                key: key,
                operator: operator,
                method: method,
                value: val
              });
            }
          }
        }
      } else {
        if ((method === 'where' || method === 'orWhere') && _.isNull(value)) {
          method = method + "Null";
        }
        condition = {
          key: key,
          value: value,
          method: method
        };
      }
      return condition;
    };

    SqlAst.prototype.parseDotRelation = function(key, value) {};

    SqlAst.prototype.parseManyToManyRelation = function(key, value, reverse_relation) {
      var relation;
      return relation = reverse_relation.reverse_relation;
    };

    return SqlAst;

  })();

}).call(this);
