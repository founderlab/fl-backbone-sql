// Generated by CoffeeScript 1.10.0

/*
  backbone-sql.js 0.6.5
  Copyright (c) 2013 Vidigami - https://github.com/vidigami/backbone-sql
  License: MIT (http://www.opensource.org/licenses/mit-license.php)
 */

(function() {
  var COMPARATORS, COMPARATOR_KEYS, SqlAst, _,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ = require('lodash');

  COMPARATORS = {
    $lt: '<',
    $lte: '<=',
    $gt: '>',
    $gte: '>=',
    $ne: '!=',
    $eq: '='
  };

  COMPARATOR_KEYS = _.keys(COMPARATORS);


  /*
  tree = {
  
    select: ['t.id', 't.name'],
  
    where: {
      method: 'where',
      conditions: [{
        method: 'where',
        column: 't.id',
        value: 1,
      }, {
        method: 'where',
        operator: '>',
        column: 't.id',
        value: 2,
      }, {
        method: 'where',
        conditions: [
          {method: 'orWhere', column: 't.id', value: 2},
          {method: 'orWhere', column: 't.id', value: 3},
          {method: 'orWhere', column: 't.id', operator: '>=' value: 99},
        ],
      }],
    },
  
    join: {
  
    },
  
    sort: ['t.id'],
  
    limit: 5,
  
  }
   */

  module.exports = SqlAst = (function() {
    function SqlAst() {
      this.select = [];
      this.where = {
        method: 'where',
        conditions: []
      };
      this.joins = {};
      this.sort = null;
      this.limit = null;
    }

    SqlAst.prototype.print = function() {
      var k, v;
      console.log('********************** AST ******************************');
      console.log('---- Input ----');
      console.log('> query:', this.query);
      console.log();
      console.log('----  AST  ----');
      console.log('> select:', this.select);
      console.log('> where:');
      console.dir(this.where, {
        depth: null,
        colors: true
      });
      console.log('> joins:', (function() {
        var ref, results;
        ref = this.joins;
        results = [];
        for (k in ref) {
          v = ref[k];
          results.push([k, v.columns]);
        }
        return results;
      }).call(this));
      console.log('> sort:', this.sort);
      console.log('> limit:', this.limit);
      return console.log('---------------------------------------------------------');
    };

    SqlAst.prototype.parse = function(options) {
      var i, k, key, len, ref, v;
      this.find = options.find || {};
      this.cursor = options.cursor || {};
      this.query = _.extend({}, this.find, this.cursor);
      this.model_type = options.model_type;
      this.prefix_columns = options.prefix_columns !== false;
      if (this.cursor.$sort) {
        this.sort = _.isArray(this.cursor.$sort) ? this.cursor.$sort : [this.cursor.$sort];
      }
      if (this.cursor.$count) {
        this.count = true;
      }
      if (this.cursor.$exists) {
        this.exists = true;
      }
      this.limit = this.cursor.$limit || (this.cursor.$one ? 1 : null);
      this.offset = this.cursor.$offset;
      if (this.cursor.$include) {
        this.prefix_columns = true;
        ref = this.cursor.$include;
        for (i = 0, len = ref.length; i < len; i++) {
          key = ref[i];
          this.join(key);
        }
        console.log('joined', (function() {
          var ref1, results;
          ref1 = this.joins;
          results = [];
          for (k in ref1) {
            v = ref1[k];
            results.push([k, v.columns]);
          }
          return results;
        }).call(this));
      }
      this._parse(this.query, {
        table: this.model_type.tableName()
      });
      return this.setSelectedColumns();
    };

    SqlAst.prototype.columnName = function(col, table) {
      if (table && this.prefix_columns) {
        return table + "." + col;
      } else {
        return col;
      }
    };

    SqlAst.prototype.prefixColumn = function(col, table) {
      return table + "." + col + " as " + (this.tablePrefix(table)) + col;
    };

    SqlAst.prototype.tablePrefix = function(table) {
      return table + "_";
    };

    SqlAst.prototype.prefixRegex = function(table) {
      table || (table = this.model_type.tableName());
      return new RegExp("^" + (this.tablePrefix(table)) + "(.*)$");
    };

    SqlAst.prototype.getRelation = function(key, model_type) {
      var relation;
      model_type || (model_type = this.model_type);
      if (!(relation = model_type.relation(key))) {
        throw new Error(key + " is not a relation of " + model_type.model_name);
      }
      return relation;
    };

    SqlAst.prototype.join = function(key, relation) {
      var base, col, model_type;
      console.log('JOINING', key);
      relation || (relation = this.getRelation(key));
      model_type = relation.reverse_relation.model_type;
      return (base = this.joins)[key] || (base[key] = {
        key: key,
        relation: relation,
        model_type: model_type,
        columns: (function() {
          var i, len, ref, results;
          ref = model_type.schema().columns();
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            col = ref[i];
            results.push(this.prefixColumn(col, model_type.tableName()));
          }
          return results;
        }).call(this)
      });
    };

    SqlAst.prototype._parse = function(query, options) {
      var cond, i, key, len, q, ref, ref1, relation, relation_name, results, reverse_relation, table, value;
      if (options == null) {
        options = {};
      }
      table = options.table;
      for (key in query) {
        value = query[key];
        if (!(key[0] !== '$')) {
          continue;
        }
        if (_.isUndefined(value)) {
          throw new Error("Unexpected undefined for query key '" + key + "'");
        }
        if (key.indexOf('.') > 0) {
          this.prefix_columns = true;
          ref = this.parseDotRelation(key, value), cond = ref[0], relation_name = ref[1], relation = ref[2];
          console.log('[cond, relation_name]', [cond, relation_name]);
          this.join(relation_name, relation);
          this.where.conditions.push(cond);
        } else if ((reverse_relation = this.model_type.reverseRelation(key)) && reverse_relation.join_table) {
          this.parseManyToManyRelation(key, value, reverse_relation);
        } else {
          cond = this.parseCondition(key, value, {
            table: table,
            method: options.method
          });
          this.where.conditions.push(cond);
        }
      }
      if (query != null ? query.$ids : void 0) {
        cond = this.parseCondition('id', {
          $in: query.$ids
        }, {
          table: table
        });
        this.where.conditions.push(cond);
      }
      if (query != null ? query.$or : void 0) {
        ref1 = query.$or;
        results = [];
        for (i = 0, len = ref1.length; i < len; i++) {
          q = ref1[i];
          results.push(this._parse(q, {
            table: table,
            method: 'orWhere'
          }));
        }
        return results;
      }
    };

    SqlAst.prototype.parseDotRelation = function(key, value) {
      var cond, ref, related_field, relation, relation_name;
      ref = key.split('.'), relation_name = ref[0], related_field = ref[1];
      console.log('key, relation_name, related_field', key, relation_name, related_field);
      relation = this.getRelation(relation_name);
      cond = this.parseCondition(related_field, value, {
        table: relation.reverse_relation.model_type.tableName()
      });
      return [cond, relation_name, relation];
    };

    SqlAst.prototype.parseManyToManyRelation = function(key, value, reverse_relation) {
      var relation;
      return relation = reverse_relation.reverse_relation;
    };

    SqlAst.prototype.parseCondition = function(key, value, options) {
      var condition, method, mongo_conditions, mongo_op, operator, val;
      if (options == null) {
        options = {};
      }
      method = options.method || 'where';
      key = this.columnName(key, options.table);
      condition = {};
      if (_.isObject(value)) {
        condition = {
          method: method,
          conditions: []
        };
        if (value != null ? value.$in : void 0) {
          condition.conditions.push({
            key: key,
            method: 'whereIn',
            value: value.$in
          });
        }
        if (value != null ? value.$nin : void 0) {
          condition.conditions.push({
            key: key,
            method: 'whereNotIn',
            value: value.$nin
          });
        }
        if ((value != null ? value.$exists : void 0) != null) {
          condition.conditions.push({
            key: key,
            method: ((value != null ? value.$exists : void 0) ? 'whereNotNull' : 'whereNull')
          });
        }
        if (_.isObject(value) && value.$like) {
          val = indexOf.call(value.$like, '%') >= 0 ? value.$like : "%" + value.$like + "%";
          condition.conditions.push({
            key: key,
            method: method,
            operator: 'ilike',
            value: val
          });
        }
        if (_.size(mongo_conditions = _.pick(value, COMPARATOR_KEYS))) {
          for (mongo_op in mongo_conditions) {
            val = mongo_conditions[mongo_op];
            operator = COMPARATORS[mongo_op];
            if (mongo_op === '$ne') {
              if (_.isNull(val)) {
                condition.conditions.push({
                  key: key,
                  method: method + "NotNull"
                });
              } else {
                condition.conditions.push({
                  method: method,
                  conditions: [
                    {
                      key: key,
                      operator: operator,
                      method: 'orWhere',
                      value: val
                    }, {
                      key: key,
                      method: 'orWhereNull'
                    }
                  ]
                });
              }
            } else if (_.isNull(val)) {
              if (mongo_op === '$eq') {
                condition.conditions.push({
                  key: key,
                  method: method + "Null"
                });
              } else {
                throw new Error("Unexpected null with query key '" + key + "': '" + mongo_conditions + "'");
              }
            } else {
              condition.conditions.push({
                key: key,
                operator: operator,
                method: method,
                value: val
              });
            }
          }
        }
      } else {
        if ((method === 'where' || method === 'orWhere') && _.isNull(value)) {
          method = method + "Null";
        }
        condition = {
          key: key,
          value: value,
          method: method
        };
      }
      if (_.isArray(condition.conditions) && condition.conditions.length === 1) {
        return condition.conditions[0];
      }
      return condition;
    };

    SqlAst.prototype.setSelectedColumns = function() {
      var col, i, key, len, ref, results;
      this.columns = this.model_type.schema().columns();
      if (indexOf.call(this.columns, 'id') < 0) {
        this.columns.unshift('id');
      }
      if (this.cursor.$values) {
        this.fields = this.cursor.$whitelist ? _.intersection(this.cursor.$values, this.cursor.$whitelist) : this.cursor.$values;
      } else if (this.cursor.$select) {
        this.fields = this.cursor.$whitelist ? _.intersection(this.cursor.$select, this.cursor.$whitelist) : this.cursor.$select;
      } else if (this.cursor.$whitelist) {
        this.fields = this.cursor.$whitelist;
      } else {
        this.fields = this.columns;
      }
      this.select = this.prefix_columns ? (function() {
        var i, len, ref, results;
        ref = this.fields;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          col = ref[i];
          results.push(this.prefixColumn(col, this.model_type.tableName()));
        }
        return results;
      }).call(this) : this.fields;
      if (this.cursor.$include) {
        ref = this.cursor.$include;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          key = ref[i];
          results.push(this.select = this.select.concat(this.joins[key].columns));
        }
        return results;
      }
    };

    return SqlAst;

  })();

}).call(this);
