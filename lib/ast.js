// Generated by CoffeeScript 1.10.0

/*
  backbone-sql.js 0.6.5
  Copyright (c) 2013 Vidigami - https://github.com/vidigami/backbone-sql
  License: MIT (http://www.opensource.org/licenses/mit-license.php)
 */

(function() {
  var COMPARATORS, COMPARATOR_KEYS, SqlAst, _,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ = require('lodash');

  COMPARATORS = {
    $lt: '<',
    $lte: '<=',
    $gt: '>',
    $gte: '>=',
    $ne: '!=',
    $eq: '='
  };

  COMPARATOR_KEYS = _.keys(COMPARATORS);

  module.exports = SqlAst = (function() {
    function SqlAst(options) {
      this.select = [];
      this.where = {
        method: 'where',
        conditions: []
      };
      this.joins = {};
      this.sort = null;
      this.limit = null;
      if (options) {
        this.parse(options);
      }
    }

    SqlAst.prototype.parse = function(options) {
      var i, key, len, ref;
      this.find = options.find || {};
      this.cursor = options.cursor || {};
      this.query = options.query || _.extend({}, this.find, this.cursor);
      if (!(this.model_type = options.model_type)) {
        throw new Error('Ast requires a model_type option');
      }
      this.prefix_columns = options.prefix_columns;
      if (this.query.$sort) {
        this.sort = _.isArray(this.query.$sort) ? this.query.$sort : [this.query.$sort];
      }
      if (this.query.$count) {
        this.count = true;
      }
      if (this.query.$exists) {
        this.exists = true;
      }
      this.limit = this.query.$limit || (this.query.$one ? 1 : null);
      this.offset = this.query.$offset;
      if (this.query.$include) {
        if (!_.isArray(this.query.$include)) {
          this.query.$include = [this.query.$include];
        }
        this.prefix_columns = true;
        ref = this.query.$include;
        for (i = 0, len = ref.length; i < len; i++) {
          key = ref[i];
          this.join(key, this.getRelation(key), {
            include: true
          });
        }
      }
      this.where.conditions = this._parseConditions(this.query, {
        table: this.model_type.tableName()
      });
      return this.setSelectedColumns();
    };

    SqlAst.prototype._parseConditions = function(query, options) {
      var cond, conditions, i, key, len, or_where, q, ref, ref1, ref2, relation, relation_name, reverse_relation, table, value;
      if (options == null) {
        options = {};
      }
      table = options.table;
      conditions = [];
      for (key in query) {
        value = query[key];
        if (!(key[0] !== '$')) {
          continue;
        }
        if (_.isUndefined(value)) {
          throw new Error("Unexpected undefined for query key '" + key + "'");
        }
        if (key.indexOf('.') > 0) {
          cond = this.parseJsonField(key, value);
          if (!cond) {
            ref = this.parseDotRelation(key, value), cond = ref[0], relation_name = ref[1], relation = ref[2];
            this.join(relation_name, relation, {
              condition: true
            });
          }
          conditions.push(cond);
        } else if ((reverse_relation = this.model_type.reverseRelation(key)) && reverse_relation.join_table) {
          ref1 = this.parseManyToManyRelation(key, value, reverse_relation), cond = ref1[0], relation_name = ref1[1], relation = ref1[2];
          this.join(relation_name, relation, {
            pivot_only: true
          });
          conditions.push(cond);
        } else {
          cond = this.parseCondition(key, value, {
            table: table,
            method: options.method
          });
          conditions.push(cond);
        }
      }
      if (query != null ? query.$ids : void 0) {
        cond = this.parseCondition('id', {
          $in: query.$ids
        }, {
          table: table
        });
        conditions.push(cond);
        if (!query.$ids.length) {
          this.abort = true;
        }
      }
      if (query != null ? query.$or : void 0) {
        or_where = {
          method: 'where',
          conditions: []
        };
        ref2 = query.$or;
        for (i = 0, len = ref2.length; i < len; i++) {
          q = ref2[i];
          or_where.conditions = or_where.conditions.concat(this._parseConditions(q, {
            table: table,
            method: 'orWhere'
          }));
        }
        conditions.push(or_where);
      }
      return conditions;
    };

    SqlAst.prototype.isJsonField = function(json_field) {
      var field, ref;
      field = this.model_type.schema().fields[json_field];
      return field && ((ref = field.type.toLowerCase()) === 'json' || ref === 'jsonb');
    };

    SqlAst.prototype.parseJsonField = function(key, value) {
      var attr, cond, json_field, ref;
      ref = key.split('.'), json_field = ref[0], attr = ref[1];
      if (this.isJsonField(json_field)) {
        cond = {
          method: 'whereRaw',
          key: json_field + " @> ?",
          value: "[{\"" + attr + "\": \"" + value + "\"}]"
        };
        return cond;
      }
      return null;
    };

    SqlAst.prototype.parseDotRelation = function(key, value) {
      var cond, ref, related_field, relation, relation_name;
      ref = key.split('.'), relation_name = ref[0], related_field = ref[1];
      relation = this.getRelation(relation_name);
      cond = this.parseCondition(related_field, value, {
        table: relation.reverse_relation.model_type.tableName()
      });
      return [cond, relation_name, relation];
    };

    SqlAst.prototype.parseManyToManyRelation = function(key, value, reverse_relation) {
      var cond, relation, relation_name;
      relation = reverse_relation.reverse_relation;
      relation_name = relation.key;
      cond = this.parseCondition(reverse_relation.foreign_key, value, {
        table: relation.join_table.tableName()
      });
      return [cond, relation_name, relation];
    };

    SqlAst.prototype.parseCondition = function(_key, value, options) {
      var condition, i, key, len, method, mongo_conditions, mongo_op, operator, ref, val;
      if (options == null) {
        options = {};
      }
      method = options.method || 'where';
      key = this.columnName(_key, options.table);
      condition = {};
      if (_.isObject(value) && !_.isDate(value)) {
        condition = {
          method: method,
          conditions: []
        };
        if (value != null ? value.$in : void 0) {
          if (!value.$in.length) {
            this.abort = true;
            return condition;
          }
          if (this.isJsonField(_key)) {
            ref = value.$in;
            for (i = 0, len = ref.length; i < len; i++) {
              val = ref[i];
              condition.conditions.push({
                method: 'orWhere',
                conditions: [
                  {
                    method: 'whereRaw',
                    key: '?? \\? ?',
                    value: [key, val]
                  }
                ]
              });
            }
            return condition;
          } else {
            condition.conditions.push({
              key: key,
              method: 'whereIn',
              value: value.$in
            });
          }
        }
        if (value != null ? value.$nin : void 0) {
          condition.conditions.push({
            key: key,
            method: 'whereNotIn',
            value: value.$nin
          });
        }
        if ((value != null ? value.$exists : void 0) != null) {
          condition.conditions.push({
            key: key,
            method: ((value != null ? value.$exists : void 0) ? 'whereNotNull' : 'whereNull')
          });
        }
        if (_.isObject(value) && value.$like) {
          val = indexOf.call(value.$like, '%') >= 0 ? value.$like : "%" + value.$like + "%";
          condition.conditions.push({
            key: key,
            method: method,
            operator: 'ilike',
            value: val
          });
        }
        if (_.size(mongo_conditions = _.pick(value, COMPARATOR_KEYS))) {
          for (mongo_op in mongo_conditions) {
            val = mongo_conditions[mongo_op];
            operator = COMPARATORS[mongo_op];
            if (mongo_op === '$ne') {
              if (_.isNull(val)) {
                condition.conditions.push({
                  key: key,
                  method: method + "NotNull"
                });
              } else {
                condition.conditions.push({
                  method: method,
                  conditions: [
                    {
                      key: key,
                      operator: operator,
                      method: 'orWhere',
                      value: val
                    }, {
                      key: key,
                      method: 'orWhereNull'
                    }
                  ]
                });
              }
            } else if (_.isNull(val)) {
              if (mongo_op === '$eq') {
                condition.conditions.push({
                  key: key,
                  method: method + "Null"
                });
              } else {
                throw new Error("Unexpected null with query key '" + key + "': '" + mongo_conditions + "'");
              }
            } else {
              condition.conditions.push({
                key: key,
                operator: operator,
                method: method,
                value: val
              });
            }
          }
        }
      } else {
        if ((method === 'where' || method === 'orWhere') && _.isNull(value)) {
          method = method + "Null";
        }
        condition = {
          key: key,
          value: value,
          method: method
        };
      }
      if (_.isArray(condition.conditions) && condition.conditions.length === 1) {
        return condition.conditions[0];
      }
      return condition;
    };

    SqlAst.prototype.join = function(key, relation, options) {
      var col, model_type;
      if (options == null) {
        options = {};
      }
      this.prefix_columns = true;
      relation || (relation = this.getRelation(key));
      model_type = relation.reverse_relation.model_type;
      return this.joins[key] = _.extend(this.joins[key] || {}, {
        key: key,
        relation: relation,
        model_type: model_type,
        columns: (function() {
          var i, len, ref, results;
          ref = model_type.schema().columns();
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            col = ref[i];
            results.push(this.prefixColumn(col, model_type.tableName()));
          }
          return results;
        }).call(this)
      }, options);
    };

    SqlAst.prototype.setSelectedColumns = function() {
      var col, i, key, len, ref, results;
      this.columns = this.model_type.schema().columns();
      if (indexOf.call(this.columns, 'id') < 0) {
        this.columns.unshift('id');
      }
      if (this.query.$values) {
        this.fields = this.query.$whitelist ? _.intersection(this.query.$values, this.query.$whitelist) : this.query.$values;
      } else if (this.query.$select) {
        this.fields = this.query.$whitelist ? _.intersection(this.query.$select, this.query.$whitelist) : this.query.$select;
      } else if (this.query.$whitelist) {
        this.fields = this.query.$whitelist;
      } else {
        this.fields = this.columns;
      }
      this.select = this.prefix_columns ? (function() {
        var i, len, ref, results;
        ref = this.fields;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          col = ref[i];
          results.push(this.prefixColumn(col, this.model_type.tableName()));
        }
        return results;
      }).call(this) : this.fields;
      if (this.query.$include) {
        ref = this.query.$include;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          key = ref[i];
          results.push(this.select = this.select.concat(this.joins[key].columns));
        }
        return results;
      }
    };

    SqlAst.prototype.jsonColumnName = function(attr, col, table) {
      return table + "->'" + col + "'->>'" + attr + "'";
    };

    SqlAst.prototype.columnName = function(col, table) {
      return table + "." + col;
    };

    SqlAst.prototype.prefixColumn = function(col, table) {
      return table + "." + col + " as " + (this.tablePrefix(table)) + col;
    };

    SqlAst.prototype.prefixColumns = function(cols, table) {
      var col, i, len, results;
      results = [];
      for (i = 0, len = cols.length; i < len; i++) {
        col = cols[i];
        results.push(this.prefixColumn(col, table));
      }
      return results;
    };

    SqlAst.prototype.tablePrefix = function(table) {
      return table + "_";
    };

    SqlAst.prototype.prefixRegex = function(table) {
      table || (table = this.model_type.tableName());
      return new RegExp("^" + (this.tablePrefix(table)) + "(.*)$");
    };

    SqlAst.prototype.getRelation = function(key, model_type) {
      var relation;
      model_type || (model_type = this.model_type);
      if (!(relation = model_type.relation(key))) {
        throw new Error(key + " is not a relation of " + model_type.model_name);
      }
      return relation;
    };

    SqlAst.prototype.joinedIncludesWithConditions = function() {
      var join, key, ref, results;
      ref = this.joins;
      results = [];
      for (key in ref) {
        join = ref[key];
        if (join.include && join.condition) {
          results.push(join);
        }
      }
      return results;
    };

    SqlAst.prototype.print = function() {
      var join, key;
      console.log('********************** AST ******************************');
      console.log('---- Input ----');
      console.log('> query:', this.query);
      console.log();
      console.log('----  AST  ----');
      console.log('> select:', this.select);
      console.log('> where:');
      console.dir(this.where, {
        depth: null,
        colors: true
      });
      console.log('> joins:', (function() {
        var ref, results;
        ref = this.joins;
        results = [];
        for (key in ref) {
          join = ref[key];
          results.push([key, join.columns]);
        }
        return results;
      }).call(this));
      console.log('> count:', this.count);
      console.log('> exists:', this.exists);
      console.log('> sort:', this.sort);
      console.log('> limit:', this.limit);
      return console.log('---------------------------------------------------------');
    };

    return SqlAst;

  })();

}).call(this);
