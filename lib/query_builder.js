// Generated by CoffeeScript 1.11.1
(function() {
  var _, appendLimits, appendSelect, appendSort, appendWhere, buildQueryFromAst, joinToRelation, parseSortField;

  _ = require('lodash');

  module.exports = buildQueryFromAst = function(query, ast, options) {
    var join, join_options, key, ref;
    if (options == null) {
      options = {};
    }
    appendWhere(query, ast.where);
    ref = ast.joins;
    for (key in ref) {
      join = ref[key];
      join_options = {
        pivot_only: join.pivot_only && !(join.include || join.condition)
      };
      joinToRelation(query, ast.model_type, join.relation, join_options);
    }
    if (ast.count || options.count) {
      return query.count('*');
    }
    if (ast.exists || options.exists) {
      return query.count('*').limit(1);
    }
    if (!_.size(ast.joins)) {
      appendLimits(query, ast.limit, ast.offset);
    }
    appendSelect(query, ast);
    appendSort(query, ast.sort);
    return query;
  };

  joinToRelation = function(query, model_type, relation, options) {
    var from_key, pivot_from_key, pivot_table, pivot_to_key, related_model_type, to_key;
    if (options == null) {
      options = {};
    }
    related_model_type = relation.reverse_relation.model_type;
    if (relation.type === 'hasMany' && relation.reverse_relation.type === 'hasMany') {
      pivot_table = relation.join_table.tableName();
      from_key = (model_type.tableName()) + ".id";
      pivot_to_key = pivot_table + "." + relation.foreign_key;
      query.leftOuterJoin(pivot_table, from_key, '=', pivot_to_key);
      if (!options.pivot_only) {
        pivot_from_key = pivot_table + "." + relation.reverse_relation.foreign_key;
        to_key = (related_model_type.tableName()) + ".id";
        return query.leftOuterJoin(related_model_type.tableName(), pivot_from_key, '=', to_key);
      }
    } else {
      if (relation.type === 'belongsTo') {
        from_key = (model_type.tableName()) + "." + relation.foreign_key;
        to_key = (related_model_type.tableName()) + ".id";
      } else {
        from_key = (model_type.tableName()) + ".id";
        to_key = (related_model_type.tableName()) + "." + relation.foreign_key;
      }
      return query.leftOuterJoin(related_model_type.tableName(), from_key, '=', to_key);
    }
  };

  appendWhere = function(query, condition) {
    var ref;
    if (!_.isUndefined(condition.key)) {
      if (condition.operator) {
        query[condition.method](condition.key, condition.operator, condition.value);
      } else {
        query[condition.method](condition.key, condition.value);
      }
    } else if ((ref = condition.conditions) != null ? ref.length : void 0) {
      query[condition.method](function() {
        var c, i, len, ref1, results, sub_query;
        sub_query = this;
        ref1 = condition.conditions;
        results = [];
        for (i = 0, len = ref1.length; i < len; i++) {
          c = ref1[i];
          results.push(appendWhere(sub_query, c));
        }
        return results;
      });
    }
    return query;
  };

  module.exports.parseSortField = parseSortField = function(sort) {
    if (sort[0] === '-') {
      return [sort.substr(1), 'desc'];
    }
    return [sort, 'asc'];
  };

  appendSelect = function(query, ast) {
    query.select(ast.select);
    return query;
  };

  appendSort = function(query, sort_fields) {
    var col, dir, i, len, ref, sort;
    if (!sort_fields) {
      return query;
    }
    for (i = 0, len = sort_fields.length; i < len; i++) {
      sort = sort_fields[i];
      ref = parseSortField(sort), col = ref[0], dir = ref[1];
      query.orderBy(col, dir);
    }
    return query;
  };

  appendLimits = function(query, limit, offset) {
    if (limit) {
      query.limit(limit);
    }
    if (offset) {
      query.offset(offset);
    }
    return query;
  };

}).call(this);
